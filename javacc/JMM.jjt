options {
    LOOKAHEAD = 1;
    FORCE_LA_CHECK = true;
}

PARSER_BEGIN(JMM)

import java.io.FileInputStream;
import java.io.FileNotFoundException;

public class JMM {
    public static void main(String[] args) throws ParseException, FileNotFoundException {
        JMM jmm = new JMM(new FileInputStream(args[0]));
        SimpleNode root = jmm.Program(); // returns reference to root node

        root.dump(""); // prints the tree on the screen
    }
}

PARSER_END(JMM)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

TOKEN : {
    <IMPORT: "import">
    | <CLASS: "class">
    | <EXTENDS: "extends">
    | <PUBLIC: "public">
    | <INT: "int">
    | <BOOLEAN: "boolean">
    | <RETURN: "return">
    | <STATIC: "static">
    | <VOID: "void">
    | <MAIN: "main">
    | <STRING: "String">
    | <IF: "if">
    | <ELSE: "else">
    | <WHILE: "while">
    | <LENGTH: "length">
    | <TRUE: "true">
    | <FALSE: "false">
    | <THIS: "this">
    | <NEW: "new">
    | <IDENTIFIER: (["a"-"z", "A"-"Z", "_", "$"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])+ | ["a"-"z", "A"-"Z"](["a"-"z", "A"-"Z", "0"-"9", "_", "$"])*)>
    | <INTEGER_LITERAL: ["0"-"9"](["0"-"9"])*>
    | <ASSIGN: "=">
    | <LBR: "{">
    | <RBR: "}">
    | <LSQBR: "[">
    | <RSQBR: "]">
    | <LPAR: "(">
    | <RPAR: ")">
    | <DOT: ".">
    | <COMMA: ",">
    | <SEMICOLON: ";">
    | <AND: "&&">
    | <LT: "<">
    | <ADD: "+">
    | <SUB: "-">
    | <MUL: "*">
    | <DIV: "/">
    | <NOT: "!">
}

SimpleNode Program() : {} {
    ImportDeclaration() ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration() : {} {
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration() : {} {
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <LBR> (VarDeclaration())* (MethodDeclaration())* <RBR>
}

void VarDeclaration() : {} {
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : {} {
    <PUBLIC> MethodDeclarationAux()
}

void MethodDeclarationAux() : {} {
    (Type() <IDENTIFIER> <LPAR> (Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*)?
    <RPAR> <LBR> (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RETURN> ExpressionWithIdentifier() <SEMICOLON> <RBR>)
    | (<STATIC> <VOID> <MAIN> <LPAR> <STRING> <LSQBR> <RSQBR> <IDENTIFIER> <RPAR> <LBR>
    (LOOKAHEAD(2) VarDeclaration())* (Statement())* <RBR>)
}

void Type() : {} {
    (<INT> (<LSQBR> <RSQBR>)?)
    | <BOOLEAN>
    | <IDENTIFIER>
}

void Statement() : {} {
    // (<IDENTIFIER> <LSQBR> Expression() <RSQBR> <ASSIGN> Expression() <SEMICOLON>)
    <IDENTIFIER> IdentifierExpression() <SEMICOLON>
    | Expression() <SEMICOLON>
    | (<LBR> (Statement())* <RBR>)
    | (<IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement())
    | (
    try {
        <WHILE> <LPAR> Expression() <RPAR>
    }
    catch (ParseException ex) {
        System.out.println(ex.toString());
        skipToStatement();
    } Statement())
    // | (Expression() <SEMICOLON>)
    // | (<IDENTIFIER> StatementAssign())
}

JAVACODE
void skipToStatement() {
    Token t;

    /*  Ignores tokens until a LBR token is found (but doesn't consume it) or until the last RPAR token is found
        in a chain of RPAR tokens */

    do {
        t = getNextToken();
    }
    while (getToken(1).kind != LBR && (t.kind != RPAR || getToken(1).kind == RPAR));
}

void IdentifierExpression() : {} {
    <ASSIGN> ExpressionWithIdentifier()
    | <LSQBR> ExpressionWithIdentifier() <RSQBR> (<ASSIGN> ExpressionWithIdentifier())?
    | ExpressionLRest()
}

// Can be deleted
void AuxiliarExpressionStatement() : {} {
    (<IDENTIFIER> AuxiliarExpressionLStatement()) // Changed line
    | <INTEGER_LITERAL> ExpressionL()
    | <TRUE> ExpressionL()
    | <FALSE> ExpressionL()
    // | <IDENTIFIER> (ExpressionL() <SEMICOLON> | StatementAssign()) // Changed line
    | <THIS> ExpressionL()
    | <NEW> ExpressionNew()
    | <NOT> Expression() ExpressionL()
    | <LPAR> Expression() <RPAR> ExpressionL()
}

// Can be deleted
void AuxiliarExpressionLStatement() : {} {
    <LSQBR> Expression() <RSQBR> (ExpressionL() <SEMICOLON> | <ASSIGN> Expression()) // Changed Line
    | (<AND> | <LT> | <ADD> | <SUB> | <MUL> | <DIV>) Expression() ExpressionL()
    | <DOT> ExpressionLDot()
    | <ASSIGN> Expression()
    // | <LSQBR> Expression() <RSQBR> <ASSIGN> Expression() <SEMICOLON>)
    | {}
}

// void StatementAssign() : {} {
//     (<ASSIGN> Expression() <SEMICOLON> | <LSQBR> Expression() <RSQBR> <ASSIGN> Expression() <SEMICOLON>)
// }

void ExpressionWithIdentifier() : {} {
    //<IDENTIFIER> ExpressionL()
    Expression()
}

void Expression() : {} {
    ExpressionAnd()
    //| (<LPAR> ExpressionWithIdentifier() <RPAR> ExpressionL())
}

void ExpressionNew() : {} {
    (<INT> <LSQBR> ExpressionWithIdentifier() <RSQBR> ExpressionL())
    | (<IDENTIFIER> <LPAR> <RPAR> ExpressionL())
}

void ExpressionL() #void : {} {
    (<LSQBR> ExpressionWithIdentifier() <RSQBR> ExpressionL())
    | ExpressionLRest()
}

void ExpressionLRest() #void : {} {
    //((<AND> | <LT> | <ADD> #Add | <SUB> | <MUL> #Mul | <DIV>) ExpressionWithIdentifier() ExpressionL())
    (<DOT> ExpressionLDot())
    | {}
}

void ExpressionAnd() #void : {} {
    ExpressionLess() (<AND> ExpressionLess() #And(2))*
}

void ExpressionLess() #void : {} {
    ExpressionAddSub() (<LT> ExpressionAddSub() #LessThan(2))*
}

void ExpressionAddSub() #void : {} {
    ExpressionMulDiv() ((<ADD> ExpressionMulDiv() #Add(2) | <SUB> ExpressionMulDiv() #Sub(2)))*
}

void ExpressionMulDiv() #void : {} {
    ExpressionNot() ((<MUL> ExpressionNot() #Mul(2) | <DIV> ExpressionNot() #Div(2)))*
}

void ExpressionNot() #void : {} {
    <NOT> ExpressionNot() #Not(1)
    | Primary()
}

void Primary() #void : {} {
    <LPAR> ExpressionWithIdentifier() <RPAR> ExpressionL()
    | <INTEGER_LITERAL> #Int ExpressionL()
    | <IDENTIFIER> #Var ExpressionL()
    | <THIS> #This ExpressionL()
    | <NEW> #New ExpressionNew()
    | <TRUE> #True ExpressionL()
    | <FALSE> #False ExpressionL()
    //| <NOT> #Not ExpressionWithIdentifier() ExpressionL()
}

void ExpressionLDot() : {} {
    (<IDENTIFIER> <LPAR> (ExpressionWithIdentifier() (<COMMA> ExpressionWithIdentifier())*)? <RPAR> ExpressionL())
    | (<LENGTH> ExpressionL())
}
